<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Batch Guide</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="User guide for the batch-rs library.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="batch.html">Batch</a></li><li><a href="installation.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li><a href="getting-started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><a href="tasks.html"><strong aria-hidden="true">3.</strong> Tasks</a></li><li><a href="queries.html"><strong aria-hidden="true">4.</strong> Queries</a></li><li><a href="worker.html"><strong aria-hidden="true">5.</strong> Worker</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title">Batch Guide</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#batch" id="batch"><h1>Batch</h1></a>
<p>A distributed task queue library written in Rust using RabbitMQ as a message broker.</p>
<p>This library allows you to send a task to a RabbitMQ broker, so that a worker will be able to pull it and execute the associated handler. It leverages the <code>futures</code> and <code>tokio-core</code> crates to provide asynchronous I/O operations.</p>
<a class="header" href="print.html#goals" id="goals"><h2>Goals</h2></a>
<ul>
<li><strong>Safe</strong>: favor safety when possible, minimising risks and mistakes.</li>
<li><strong>Extensible</strong>: enable developers to easily add new behaviour to the Query system.</li>
<li><strong>Smart</strong>: allow developers to save time by making the easy obvious, and by providing sensible defaults.</li>
</ul>
<a class="header" href="print.html#non-goals" id="non-goals"><h2>Non Goals</h2></a>
<ul>
<li>Multiple broker adapters: for the forseeable future RabbitMQ/AMQP will be the only officially supported message broker</li>
</ul>
<a class="header" href="print.html#installation" id="installation"><h1>Installation</h1></a>
<p>Add this to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
batch = &quot;0.1&quot;
</code></pre>
<blockquote>
<p><strong>Note</strong>: Task serialization depends on <a href="https://serde.rs/"><code>serde</code></a>, so you will have to add it to your project's dependencies as well.</p>
</blockquote>
<p>Then add this to your crate root:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate batch;
#}</code></pre></pre>
<p>Examples are available on <a href="https://github.com/kureuil/batch-rs/tree/master/batch/examples">GitHub</a> or you can continue and read the Getting Started guide.</p>
<a class="header" href="print.html#getting-started" id="getting-started"><h1>Getting started</h1></a>
<p>The first thing you'll want to do once you've installed <code>batch</code> is connect to a RabbitMQ broker. We'll start by creating a <code>Client</code>:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate batch;
extern crate tokio_core;

use batch::ClientBuilder;
use tokio_core::reactor::Core;

fn main() {
    let mut core = Core::new().unwrap();
    let handle = core.handle();

    let client = ClientBuilder::new()
        .connection_url(&quot;amqp://localhost/%2f&quot;)
        .handle(handle)
        .build();

    core.run(client).unwrap();
}
</code></pre></pre>
<p>Now, that we're connected to our broker, we'll create our first task. A task is a work of unit that you want to asynchronously, becuse handling synchronously isn't possible or wouldn't be ideal (e.g sending a mail from a web API). The easiest of creating a task, is by declaring a structure, and derive <code>Task</code> on it:</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate batch;
extern crate serde;
#[macro_use]
extern crate serde_derive;
extern crate tokio_core;

use batch::ClientBuilder;
use tokio_core::reactor::Core;

#[derive(Serialize, Deserialize, Task)]
#[task_routing_key = &quot;hello-world&quot;]
struct SayHello {
    to: String,
}

fn main() {
    let mut core = Core::new().unwrap();
    let handle = core.handle();

    let client = ClientBuilder::new()
        .connection_url(&quot;amqp://localhost/%2f&quot;)
        .handle(handle)
        .build();

    core.run(client).unwrap();
}
</code></pre></pre>
<blockquote>
<p><strong>Note</strong>: you can see that in addition to <code>Task</code>, we're also deriving <code>serde</code>'s <code>Serialize</code> &amp; <code>Deserialize</code> traits. This is necessary in order to safely send task over the network.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: When deriving <code>Task</code> we added the (mandatory) <code>task_routing_key</code> attribute, it is used by RabbitMQ to deliver your message to the right worker.</p>
</blockquote>
<p>Now that we have our task, we can send it to our message broker:</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate batch;
extern crate futures;
extern crate serde;
#[macro_use]
extern crate serde_derive;
extern crate tokio_core;

use batch::{job, ClientBuilder};
use futures::Future;
use tokio_core::reactor::Core;

#[derive(Serialize, Deserialize, Task)]
#[task_routing_key = &quot;hello-world&quot;]
struct SayHello {
    to: String,
}

fn main() {
    let mut core = Core::new().unwrap();
    let handle = core.handle();

    let client = ClientBuilder::new()
        .connection_url(&quot;amqp://localhost/%2f&quot;)
        .handle(handle)
        .build();

    let send = client.and_then(|client| {
        let task = SayHello {
            to: &quot;Ferris&quot;.into()
        };

        job(task).send(&amp;client)
    });

    core.run(send).unwrap();
}
</code></pre></pre>
<p>Now that our task has been published to our broker, we'll need to fetch it and assign a function to this task. To do this, we'll create a new program, the <em>worker</em>:</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate batch;
extern crate serde;
#[macro_use]
extern crate serde_derive;
extern crate tokio_core;

use batch::{queue, WorkerBuilder};
use tokio_core::reactor::Core;

#[derive(Serialize, Deserialize, Task)]
#[task_routing_key = &quot;hello-world&quot;]
struct SayHello {
    to: String,
}

fn main() {
    let mut core = Core::new().unwrap();
    let handle = core.handle();

    let queues = vec![queue(&quot;hello-world&quot;)];
    let worker = WorkerBuilder::new(())
        .connection_url(&quot;amqp://localhost/%2f&quot;)
        .queues(queues)
        .handle(handle)
        .build()
        .unwrap();

    core.run(worker.run()).unwrap();
}
</code></pre></pre>
<p>In order to register our task on the worker, we'll need to make it executable by implementing the <code>Perform</code> trait:</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate batch;
extern crate serde;
#[macro_use]
extern crate serde_derive;
extern crate tokio_core;

use batch::{queue, Perform, WorkerBuilder};
use tokio_core::reactor::Core;

#[derive(Serialize, Deserialize, Task)]
#[task_routing_key = &quot;hello-world&quot;]
struct SayHello {
    to: String,
}

impl Perform for SayHello {
    type Context = ();

    fn perform(&amp;self, _ctx: Self::Context) {
        println!(&quot;Hello {}!&quot;, self.to);
    }
}

fn main() {
    let mut core = Core::new().unwrap();
    let handle = core.handle();

    let queues = vec![queue(&quot;hello-world&quot;)];
    let worker = WorkerBuilder::new(())
        .connection_url(&quot;amqp://localhost/%2f&quot;)
        .queues(queues)
        .handle(handle)
        .task::&lt;SayHello&gt;()
        .build()
        .unwrap();

    core.run(worker.run()).unwrap();
}
</code></pre></pre>
<p>We can now run our <em>worker</em> program and see the <code>Hello Ferris!</code> message displayed in the terminal.</p>
<a class="header" href="print.html#tasks" id="tasks"><h1>Tasks</h1></a>
<p>A task is a unit of work which computation can be deferred using <code>batch</code>. You declare a task by implementing the <code>Task</code> trait on a structure. Note that implementing this trait requires you to also implement <a href="https://serde.rs/"><code>serde</code></a>'s <code>Serialize</code> and <code>Deserialize</code> traits, this is required in order to safely send your tasks between processes.</p>
<p>The <code>Task</code> trait allows you to specify a default configuration for your task (e.g: default timeout, default number of retries). Usually you will use <code>batch</code>'s procedural macros and derive the trait:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate batch;
extern crate serde;
#[macro_use]
extern crate serde_derive;

#[derive(Serialize, Deserialize, Task)]
#[task_routing_key = &quot;messaging&quot;]
struct SayHello {
    to: String,
}
#}</code></pre></pre>
<a class="header" href="print.html#task_routing_key-attribute" id="task_routing_key-attribute"><h2><code>task_routing_key</code> attribute</h2></a>
<p>The only mandatory attribute is <code>task_routing_key</code>, which is used to transfer a task from an <em>exchange</em> (where the <code>Client</code> publishes) to a <em>queue</em> (where the <code>Worker</code> consumes messages from).</p>
<a class="header" href="print.html#task_name-attribute" id="task_name-attribute"><h2><code>task_name</code> attribute</h2></a>
<blockquote>
<p><strong>Default value</strong>: The name of the type deriving <code>Task</code></p>
</blockquote>
<p>This value is used to register and identify tasks in the worker, mapping a <code>task_name</code> to a deserializer. This attribute should be unique in your project.</p>
<a class="header" href="print.html#task_exchange-attribute" id="task_exchange-attribute"><h2><code>task_exchange</code> attribute</h2></a>
<blockquote>
<p><strong>Default value</strong>: empty string (default RabbitMQ exchange)</p>
</blockquote>
<p>This value is used when publishing a task to RabbitMQ. If you set a custom exchange name, you must ensure that it is declared before using it (see <a href="https://docs.rs/batch/0.1/batch/struct.ClientBuilder.html#method.exchanges"><code>ClientBuilder::exchanges</code></a>).</p>
<a class="header" href="print.html#task_timeout-attribute" id="task_timeout-attribute"><h2><code>task_timeout</code> attribute</h2></a>
<blockquote>
<p><strong>Default value</strong>: 900 seconds (15 minutes)</p>
</blockquote>
<p>This attribute gives the number of seconds allowed before a task execution is considered failed. If the execution of a task takes longer that the given timeout, it is stopped, marked as failed and if needed tried again.</p>
<a class="header" href="print.html#task_retries-attribute" id="task_retries-attribute"><h2><code>task_retries</code> attribute</h2></a>
<blockquote>
<p><strong>Default value</strong>: 2</p>
</blockquote>
<p>The attribute gives the number of times a task should be tried again in case of failure. When a task is retried, it is pushed as a new task would be with the exact same attributes except for the <code>task_retries</code> attribute that gets decremented.</p>
<a class="header" href="print.html#queries" id="queries"><h1>Queries</h1></a>
<p>Queries are the API used when publishing a task to the message broker. A <code>Query</code> allows you to overwrite any defaults provided by the <code>Task</code> trait and allows you to call any extension registered. A <code>Query</code> is manipulated in the same way as a builder: it exposes a fluent interface where you chain method calls, before calling the final method <code>send</code>.</p>
<p>You create a query by calling the <code>job</code> function, giving it a <code>Task</code> instance as parameter, and you send it by calling the <code>send</code> method, giving it a reference to your <code>Client</code> instance:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let client = /* your batch Client instance */;
let task = /* your batch Task instance */;
job(task).send(&amp;client);
#}</code></pre></pre>
<p>See <a href="https://docs.rs/batch/0.1/batch/struct.Query.html"><code>Query</code> API documentation</a>.</p>
<a class="header" href="print.html#worker" id="worker"><h1>Worker</h1></a>
<p>The <code>Worker</code> is the most delicate piece of code of the project because of the choices and trade-offs that have been made. It is a piece software that is designed to be always running, spawning new tasks as needed &amp; never crashing.</p>
<p>Just like the resque worker, it assumes chaos: each task is executed in its own process allowing for maximum isolation between tasks and minimum risks of shared corruption crash. It also enables features such as timeouts that would be downright impossible to implement with threads for example.</p>
<p>In order to have one process per task, the <code>Worker</code> executes itself (the current executable file) with a special environment variable signaling that it should read a task payload on the standard input instead of pulling new tasks from the message broker. This means that it might be complicated to integrate the <code>Worker</code> into an existing binary: the recommended way of using the <code>Worker</code> is by creating a dedicated binary which only goal is pulling tasks &amp; spawning processes.</p>
<p>See <a href="https://docs.rs/batch/0.1/batch/struct.Worker.html"><code>Worker</code> API documentation</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
